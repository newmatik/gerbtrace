/**
 * generate-samples.mjs
 *
 * Generates two sample Gerber ZIP archives that resemble an Arduino UNO-sized
 * PCB (≈ 2.7 × 2.1 inches).  Rev3f is a slight revision of Rev3e so that a
 * diff viewer has something interesting to show.
 *
 * Usage:  node scripts/generate-samples.mjs
 * Output: public/samples/arduino-uno-rev3e.zip
 *         public/samples/arduino-uno-rev3f.zip
 */

import { writeFile, mkdir } from "node:fs/promises";
import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";
import JSZip from "jszip";

const __dirname = dirname(fileURLToPath(import.meta.url));
const OUT_DIR = join(__dirname, "..", "public", "samples");

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/** Convenience: generates a standard RS-274X header block. */
function gerberHeader(layerComment) {
  return [
    "G04 Generated by gerbtrace sample generator*",
    `G04 Layer: ${layerComment}*`,
    "%FSLAX24Y24*%",
    "%MOIN*%",
    "%IPPOS*%",
    "%LPD*%",
  ].join("\n");
}

/** Standard aperture definitions shared by most layers. */
function standardApertures() {
  return [
    "G04 Aperture definitions*",
    "%ADD10C,0.0100*%",   // 10 mil round trace
    "%ADD11C,0.0080*%",   //  8 mil round trace
    "%ADD12C,0.0600*%",   // 60 mil round pad
    "%ADD13R,0.0600X0.0600*%", // 60 mil square pad
    "%ADD14C,0.0400*%",   // 40 mil round pad (via)
    "%ADD15C,0.1000*%",   // 100 mil round pad (through-hole)
    "%ADD16R,0.1000X0.0500*%", // 100×50 mil rectangular pad
    "%ADD17C,0.0050*%",   // 5 mil thin line (silkscreen)
    "%ADD18C,0.0120*%",   // 12 mil medium line
  ].join("\n");
}

function gerberFooter() {
  return "M02*";
}

// Quick shorthand – all coordinates are in 2.4 format (inches × 10000)
function coord(xInch, yInch) {
  const xi = Math.round(xInch * 10000);
  const yi = Math.round(yInch * 10000);
  return `X${xi}Y${yi}`;
}

function flash(x, y) {
  return `${coord(x, y)}D03*`;
}

function moveTo(x, y) {
  return `${coord(x, y)}D02*`;
}

function lineTo(x, y) {
  return `${coord(x, y)}D01*`;
}

// ---------------------------------------------------------------------------
// Board geometry constants (Arduino UNO ≈ 2.700 × 2.100 inches)
// ---------------------------------------------------------------------------

const BW = 2.7;
const BH = 2.1;

// Header pin rows (two rows along the long edges)
const headerPinsTop = [];
for (let i = 0; i < 18; i++) {
  headerPinsTop.push({ x: 0.16 + i * 0.1, y: BH - 0.15 });
}
const headerPinsBot = [];
for (let i = 0; i < 18; i++) {
  headerPinsBot.push({ x: 0.16 + i * 0.1, y: 0.15 });
}

// Power header (6 pins)
const powerPins = [];
for (let i = 0; i < 6; i++) {
  powerPins.push({ x: BW - 0.3, y: 0.4 + i * 0.1 });
}

// ICSP header (2×3)
const icspPins = [];
for (let r = 0; r < 2; r++) {
  for (let c = 0; c < 3; c++) {
    icspPins.push({ x: 1.2 + c * 0.1, y: 1.0 + r * 0.1 });
  }
}

// USB connector pads (simplified as 4 rectangular pads)
const usbPads = [
  { x: 0.15, y: 0.85 },
  { x: 0.15, y: 0.95 },
  { x: 0.15, y: 1.05 },
  { x: 0.15, y: 1.15 },
];

// Mounting holes
const mountingHoles = [
  { x: 0.15, y: 0.15 },
  { x: 0.15, y: BH - 0.15 },
  { x: BW - 0.15, y: 0.15 },
  { x: BW - 0.15, y: BH - 0.15 },
];

// Vias scattered around the board
const vias = [
  { x: 0.8, y: 0.5 },
  { x: 1.0, y: 0.7 },
  { x: 1.4, y: 0.5 },
  { x: 1.6, y: 1.3 },
  { x: 2.0, y: 0.9 },
  { x: 2.2, y: 1.5 },
];

// ---------------------------------------------------------------------------
// Layer generators
// ---------------------------------------------------------------------------

function generateTopCopper(rev) {
  const lines = [gerberHeader("Top Copper"), standardApertures(), "G01*"];

  // Flash header pin pads
  lines.push("D15*");
  for (const p of headerPinsTop) lines.push(flash(p.x, p.y));
  for (const p of headerPinsBot) lines.push(flash(p.x, p.y));

  // Power header
  lines.push("D13*");  // square pads
  for (const p of powerPins) lines.push(flash(p.x, p.y));

  // ICSP
  lines.push("D12*");
  for (const p of icspPins) lines.push(flash(p.x, p.y));

  // USB pads
  lines.push("D16*");
  for (const p of usbPads) lines.push(flash(p.x, p.y));

  // Vias
  lines.push("D14*");
  for (const v of vias) lines.push(flash(v.x, v.y));

  // Traces on top copper — connect a few header pins
  lines.push("D10*");
  lines.push(moveTo(headerPinsTop[0].x, headerPinsTop[0].y));
  lines.push(lineTo(headerPinsTop[0].x, headerPinsTop[0].y - 0.3));
  lines.push(lineTo(headerPinsBot[0].x, headerPinsBot[0].y + 0.3));
  lines.push(lineTo(headerPinsBot[0].x, headerPinsBot[0].y));

  lines.push(moveTo(headerPinsTop[5].x, headerPinsTop[5].y));
  lines.push(lineTo(headerPinsTop[5].x + 0.05, headerPinsTop[5].y - 0.4));
  lines.push(lineTo(vias[0].x, vias[0].y));

  // Rev3f adds an extra trace segment from power pin to via
  if (rev === "f") {
    lines.push("D11*");
    lines.push(moveTo(powerPins[0].x, powerPins[0].y));
    lines.push(lineTo(powerPins[0].x - 0.3, powerPins[0].y));
    lines.push(lineTo(vias[4].x, vias[4].y));
  }

  // Route from ICSP to nearby via
  lines.push("D11*");
  lines.push(moveTo(icspPins[0].x, icspPins[0].y));
  lines.push(lineTo(icspPins[0].x - 0.2, icspPins[0].y - 0.3));
  lines.push(lineTo(vias[1].x, vias[1].y));

  lines.push(gerberFooter());
  return lines.join("\n");
}

function generateBottomCopper(rev) {
  const lines = [gerberHeader("Bottom Copper"), standardApertures(), "G01*"];

  // Mirror the same pads on bottom
  lines.push("D15*");
  for (const p of headerPinsTop) lines.push(flash(p.x, p.y));
  for (const p of headerPinsBot) lines.push(flash(p.x, p.y));

  lines.push("D13*");
  for (const p of powerPins) lines.push(flash(p.x, p.y));

  lines.push("D12*");
  for (const p of icspPins) lines.push(flash(p.x, p.y));

  lines.push("D16*");
  for (const p of usbPads) lines.push(flash(p.x, p.y));

  lines.push("D14*");
  for (const v of vias) lines.push(flash(v.x, v.y));

  // Ground pour trace (simple ring around edges)
  lines.push("D18*");
  lines.push(moveTo(0.25, 0.25));
  lines.push(lineTo(BW - 0.25, 0.25));
  lines.push(lineTo(BW - 0.25, BH - 0.25));
  lines.push(lineTo(0.25, BH - 0.25));
  lines.push(lineTo(0.25, 0.25));

  // Trace connecting vias on bottom
  lines.push("D10*");
  lines.push(moveTo(vias[0].x, vias[0].y));
  lines.push(lineTo(vias[1].x, vias[1].y));
  lines.push(lineTo(vias[2].x, vias[2].y));

  lines.push(moveTo(vias[3].x, vias[3].y));
  lines.push(lineTo(vias[4].x, vias[4].y));
  lines.push(lineTo(vias[5].x, vias[5].y));

  // Rev3f: rerouted trace
  if (rev === "f") {
    lines.push("D11*");
    lines.push(moveTo(vias[2].x, vias[2].y));
    lines.push(lineTo(1.5, 0.8));
    lines.push(lineTo(vias[3].x, vias[3].y));
  }

  lines.push(gerberFooter());
  return lines.join("\n");
}

function generateSolderMask(side, _rev) {
  const layerName = side === "top" ? "Top Solder Mask" : "Bottom Solder Mask";
  const lines = [gerberHeader(layerName), standardApertures(), "%LPC*%", "G01*"];

  // Openings for every pad (clear polarity already set)
  lines.push("D15*");
  for (const p of headerPinsTop) lines.push(flash(p.x, p.y));
  for (const p of headerPinsBot) lines.push(flash(p.x, p.y));

  lines.push("D13*");
  for (const p of powerPins) lines.push(flash(p.x, p.y));

  lines.push("D12*");
  for (const p of icspPins) lines.push(flash(p.x, p.y));

  lines.push("D16*");
  for (const p of usbPads) lines.push(flash(p.x, p.y));

  lines.push("D14*");
  for (const v of vias) lines.push(flash(v.x, v.y));

  // Mounting holes
  lines.push("D15*");
  for (const m of mountingHoles) lines.push(flash(m.x, m.y));

  lines.push(gerberFooter());
  return lines.join("\n");
}

/**
 * Simple stroke-font text renderer for Gerber.
 * Each character is drawn with line segments in a 5-high × 3-wide grid.
 * Only uppercase A-Z, 0-9, space, dash, dot are supported.
 */
function strokeText(startX, startY, text, charW = 0.06, charH = 0.08) {
  // Simple vector font — each char maps to an array of polylines.
  // Coordinates range [0..3] x [0..5], scaled by charW/3 and charH/5.
  const font = {
    A: [[[0,0],[0,5],[1.5,5],[3,5],[3,0]],[[0,2.5],[3,2.5]]],
    B: [[[0,0],[0,5],[2.5,5],[3,4.5],[3,3.5],[2.5,3],[0,3]],[[2.5,3],[3,2],[3,1],[2.5,0],[0,0]]],
    C: [[[3,5],[0,5],[0,0],[3,0]]],
    D: [[[0,0],[0,5],[2,5],[3,4],[3,1],[2,0],[0,0]]],
    E: [[[3,5],[0,5],[0,0],[3,0]],[[0,2.5],[2,2.5]]],
    F: [[[0,0],[0,5],[3,5]],[[0,2.5],[2,2.5]]],
    G: [[[3,5],[0,5],[0,0],[3,0],[3,2.5],[1.5,2.5]]],
    H: [[[0,0],[0,5]],[[3,0],[3,5]],[[0,2.5],[3,2.5]]],
    I: [[[0,5],[3,5]],[[1.5,5],[1.5,0]],[[0,0],[3,0]]],
    J: [[[0,1],[0,0],[3,0],[3,5]]],
    K: [[[0,0],[0,5]],[[3,5],[0,2.5],[3,0]]],
    L: [[[0,5],[0,0],[3,0]]],
    M: [[[0,0],[0,5],[1.5,3],[3,5],[3,0]]],
    N: [[[0,0],[0,5],[3,0],[3,5]]],
    O: [[[0,0],[0,5],[3,5],[3,0],[0,0]]],
    P: [[[0,0],[0,5],[3,5],[3,2.5],[0,2.5]]],
    Q: [[[0,0],[0,5],[3,5],[3,0],[0,0]],[[2,1],[3.5,-0.5]]],
    R: [[[0,0],[0,5],[3,5],[3,2.5],[0,2.5]],[[1.5,2.5],[3,0]]],
    S: [[[3,5],[0,5],[0,2.5],[3,2.5],[3,0],[0,0]]],
    T: [[[0,5],[3,5]],[[1.5,5],[1.5,0]]],
    U: [[[0,5],[0,0],[3,0],[3,5]]],
    V: [[[0,5],[1.5,0],[3,5]]],
    W: [[[0,5],[0,0],[1.5,2],[3,0],[3,5]]],
    X: [[[0,0],[3,5]],[[0,5],[3,0]]],
    Y: [[[0,5],[1.5,2.5],[3,5]],[[1.5,2.5],[1.5,0]]],
    Z: [[[0,5],[3,5],[0,0],[3,0]]],
    "0": [[[0,0],[0,5],[3,5],[3,0],[0,0]],[[0,0],[3,5]]],
    "1": [[[1,4],[1.5,5],[1.5,0]],[[0,0],[3,0]]],
    "2": [[[0,5],[3,5],[3,2.5],[0,2.5],[0,0],[3,0]]],
    "3": [[[0,5],[3,5],[3,0],[0,0]],[[0,2.5],[3,2.5]]],
    "4": [[[0,5],[0,2.5],[3,2.5]],[[3,5],[3,0]]],
    "5": [[[3,5],[0,5],[0,2.5],[3,2.5],[3,0],[0,0]]],
    "6": [[[3,5],[0,5],[0,0],[3,0],[3,2.5],[0,2.5]]],
    "7": [[[0,5],[3,5],[3,0]]],
    "8": [[[0,0],[0,5],[3,5],[3,0],[0,0]],[[0,2.5],[3,2.5]]],
    "9": [[[3,2.5],[0,2.5],[0,5],[3,5],[3,0],[0,0]]],
    " ": [],
    "-": [[[0,2.5],[3,2.5]]],
    ".": [[[1.25,0],[1.75,0],[1.75,0.5],[1.25,0.5],[1.25,0]]],
    "/": [[[0,0],[3,5]]],
  };

  const sx = charW / 3;
  const sy = charH / 5;
  const cmds = [];

  let cursorX = startX;
  for (const ch of text.toUpperCase()) {
    const glyphs = font[ch];
    if (!glyphs) { cursorX += charW * 1.3; continue; }
    for (const polyline of glyphs) {
      if (polyline.length === 0) continue;
      const [fx, fy] = polyline[0];
      cmds.push(moveTo(cursorX + fx * sx, startY + fy * sy));
      for (let i = 1; i < polyline.length; i++) {
        const [px, py] = polyline[i];
        cmds.push(lineTo(cursorX + px * sx, startY + py * sy));
      }
    }
    cursorX += charW * 1.3;
  }
  return cmds;
}

function generateTopSilkscreen(rev) {
  const lines = [gerberHeader("Top Silkscreen"), standardApertures(), "G01*"];

  // Component outlines
  lines.push("D17*");

  // IC outline (ATmega328P area)
  lines.push(moveTo(0.9, 0.4));
  lines.push(lineTo(1.7, 0.4));
  lines.push(lineTo(1.7, 0.9));
  lines.push(lineTo(0.9, 0.9));
  lines.push(lineTo(0.9, 0.4));
  // Pin 1 marker
  lines.push(moveTo(0.95, 0.85));
  lines.push(lineTo(1.0, 0.85));
  lines.push(lineTo(1.0, 0.8));

  // USB connector outline
  lines.push(moveTo(0.02, 0.75));
  lines.push(lineTo(0.25, 0.75));
  lines.push(lineTo(0.25, 1.25));
  lines.push(lineTo(0.02, 1.25));

  // Crystal outline
  lines.push(moveTo(1.9, 0.5));
  lines.push(lineTo(2.1, 0.5));
  lines.push(lineTo(2.1, 0.7));
  lines.push(lineTo(1.9, 0.7));
  lines.push(lineTo(1.9, 0.5));

  // Capacitor outlines (two small rectangles)
  for (const cx of [2.2, 2.35]) {
    lines.push(moveTo(cx, 0.5));
    lines.push(lineTo(cx + 0.08, 0.5));
    lines.push(lineTo(cx + 0.08, 0.6));
    lines.push(lineTo(cx, 0.6));
    lines.push(lineTo(cx, 0.5));
  }

  // Voltage regulator outline
  lines.push(moveTo(2.0, 1.3));
  lines.push(lineTo(2.3, 1.3));
  lines.push(lineTo(2.3, 1.6));
  lines.push(lineTo(2.0, 1.6));
  lines.push(lineTo(2.0, 1.3));

  // LED indicator
  lines.push(moveTo(1.8, 1.5));
  lines.push(lineTo(1.9, 1.5));
  lines.push(lineTo(1.85, 1.6));
  lines.push(lineTo(1.8, 1.5));

  // Reference designators
  lines.push("D17*");
  lines.push(...strokeText(0.95, 0.55, "U1", 0.04, 0.06));
  lines.push(...strokeText(1.92, 0.52, "Y1", 0.03, 0.05));
  lines.push(...strokeText(2.22, 0.62, "C1", 0.03, 0.04));
  lines.push(...strokeText(2.37, 0.62, "C2", 0.03, 0.04));
  lines.push(...strokeText(2.02, 1.62, "U2", 0.03, 0.05));

  // Board title text
  const title = rev === "e" ? "ARDUINO UNO REV3E" : "ARDUINO UNO REV3F";
  lines.push(...strokeText(0.5, 1.4, title, 0.05, 0.07));

  // Rev3f: adds an extra reference designator and LED marker
  if (rev === "f") {
    lines.push(...strokeText(1.78, 1.62, "D1", 0.03, 0.04));
    // Extra test point outline
    lines.push(moveTo(2.45, 1.0));
    lines.push(lineTo(2.55, 1.0));
    lines.push(lineTo(2.55, 1.1));
    lines.push(lineTo(2.45, 1.1));
    lines.push(lineTo(2.45, 1.0));
    lines.push(...strokeText(2.45, 1.12, "TP1", 0.025, 0.035));
  }

  lines.push(gerberFooter());
  return lines.join("\n");
}

function generateBottomSilkscreen(rev) {
  const lines = [gerberHeader("Bottom Silkscreen"), standardApertures(), "G01*"];

  lines.push("D17*");

  // URL / branding text
  const url = rev === "e" ? "WWW.ARDUINO.CC" : "ARDUINO.CC/UNO";
  lines.push(...strokeText(0.6, 0.3, url, 0.04, 0.06));

  // Copyright line
  const copy = rev === "e" ? "REV3E 2024" : "REV3F 2025";
  lines.push(...strokeText(0.6, 0.2, copy, 0.03, 0.05));

  // Some small component outlines on bottom
  // Decoupling caps near pins
  for (const cx of [0.5, 0.7, 0.9, 1.1]) {
    lines.push(moveTo(cx, 0.45));
    lines.push(lineTo(cx + 0.06, 0.45));
    lines.push(lineTo(cx + 0.06, 0.55));
    lines.push(lineTo(cx, 0.55));
    lines.push(lineTo(cx, 0.45));
  }

  lines.push(gerberFooter());
  return lines.join("\n");
}

function generateBoardOutline(_rev) {
  const lines = [
    gerberHeader("Board Outline"),
    "%ADD10C,0.0050*%",
    "G01*",
    "D10*",
    // Rectangular outline with small corner chamfer
    moveTo(0.05, 0.0),
    lineTo(BW - 0.05, 0.0),
    lineTo(BW, 0.05),
    lineTo(BW, BH - 0.05),
    lineTo(BW - 0.05, BH),
    lineTo(0.05, BH),
    lineTo(0.0, BH - 0.05),
    lineTo(0.0, 0.05),
    lineTo(0.05, 0.0),
    gerberFooter(),
  ];
  return lines.join("\n");
}

function generateDrillFile(rev) {
  const lines = [
    "; Generated by gerbtrace sample generator",
    `; Revision: Rev3${rev}`,
    "M48",
    "INCH",
    "T01C0.0280",  // 28 mil – header pin holes
    "T02C0.0400",  // 40 mil – via holes
    "T03C0.1260",  // 126 mil – mounting holes
    "T04C0.0350",  // 35 mil – power pins
    "%",
  ];

  // Header pin holes (T01)
  lines.push("T01");
  for (const p of headerPinsTop) {
    lines.push(drillCoord(p.x, p.y));
  }
  for (const p of headerPinsBot) {
    lines.push(drillCoord(p.x, p.y));
  }
  // ICSP
  for (const p of icspPins) {
    lines.push(drillCoord(p.x, p.y));
  }

  // Via holes (T02)
  lines.push("T02");
  for (const v of vias) {
    lines.push(drillCoord(v.x, v.y));
  }

  // Rev3f adds an extra via/test point hole
  if (rev === "f") {
    lines.push(drillCoord(2.5, 1.05));
  }

  // Mounting holes (T03)
  lines.push("T03");
  for (const m of mountingHoles) {
    lines.push(drillCoord(m.x, m.y));
  }

  // Power header (T04)
  lines.push("T04");
  for (const p of powerPins) {
    lines.push(drillCoord(p.x, p.y));
  }

  lines.push("M30");
  return lines.join("\n");
}

function drillCoord(xInch, yInch) {
  // Excellon uses a simpler format — 2.4 notation
  const xStr = formatExcellon(xInch);
  const yStr = formatExcellon(yInch);
  return `X${xStr}Y${yStr}`;
}

function formatExcellon(val) {
  // Format as 2.4 (e.g. 1.2345 → 12345, 0.15 → 01500)
  const scaled = Math.round(val * 10000);
  return scaled.toString().padStart(6, "0");
}

// ---------------------------------------------------------------------------
// Build ZIP archives
// ---------------------------------------------------------------------------

async function buildZip(rev) {
  const zip = new JSZip();

  zip.file("board.gtl", generateTopCopper(rev));
  zip.file("board.gbl", generateBottomCopper(rev));
  zip.file("board.gts", generateSolderMask("top", rev));
  zip.file("board.gbs", generateSolderMask("bottom", rev));
  zip.file("board.gto", generateTopSilkscreen(rev));
  zip.file("board.gbo", generateBottomSilkscreen(rev));
  zip.file("board.gm1", generateBoardOutline(rev));
  zip.file("board.drl", generateDrillFile(rev));

  return zip.generateAsync({ type: "nodebuffer", compression: "DEFLATE" });
}

async function main() {
  await mkdir(OUT_DIR, { recursive: true });

  const [bufE, bufF] = await Promise.all([buildZip("e"), buildZip("f")]);

  const pathE = join(OUT_DIR, "arduino-uno-rev3e.zip");
  const pathF = join(OUT_DIR, "arduino-uno-rev3f.zip");

  await Promise.all([writeFile(pathE, bufE), writeFile(pathF, bufF)]);

  console.log(`Created ${pathE} (${bufE.length} bytes)`);
  console.log(`Created ${pathF} (${bufF.length} bytes)`);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
