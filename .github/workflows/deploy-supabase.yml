name: Deploy Supabase (Droplet)

on:
  push:
    branches: [main]
    paths:
      - 'supabase/**'
  workflow_dispatch:

concurrency:
  group: deploy-supabase-droplet
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Create Supabase bundle
      # Copy only what we need to deploy.
        run: |
          tar -czf supabase.tgz supabase

      - name: Upload bundle to droplet
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DROPLET_HOST }}
          username: ${{ secrets.DROPLET_USER }}
          key: ${{ secrets.DROPLET_SSH_KEY }}
          source: supabase.tgz
          target: /tmp

      - name: Apply migrations and sync functions
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.DROPLET_HOST }}
          username: ${{ secrets.DROPLET_USER }}
          key: ${{ secrets.DROPLET_SSH_KEY }}
          script_stop: true
          script: |
            set -euo pipefail

            ARCHIVE="/tmp/supabase.tgz"
            DEPLOY_DIR="/tmp/gerbtrace-supabase-${{ github.sha }}"
            SUPABASE_DOCKER_DIR="/opt/supabase/docker"
            FUNCTIONS_DST="/opt/supabase/docker/volumes/functions"

            if [ ! -f "$ARCHIVE" ]; then
              echo "Missing archive at $ARCHIVE" >&2
              exit 1
            fi
            if [ ! -d "$SUPABASE_DOCKER_DIR" ]; then
              echo "Missing Supabase docker directory at $SUPABASE_DOCKER_DIR" >&2
              exit 1
            fi

            rm -rf "$DEPLOY_DIR"
            mkdir -p "$DEPLOY_DIR"
            tar -xzf "$ARCHIVE" -C "$DEPLOY_DIR"

            cd "$SUPABASE_DOCKER_DIR"

            # Ensure migration bookkeeping table exists (idempotent).
            docker compose exec -T db psql -U postgres -d postgres -v ON_ERROR_STOP=1 \
              -c "create table if not exists public.schema_migrations (name text primary key, applied_at timestamptz not null default now());"

            # Apply migrations in timestamp order, exactly once each.
            for f in $(ls -1 "$DEPLOY_DIR"/supabase/migrations/*.sql | sort); do
              name="$(basename "$f")"
              applied="$(docker compose exec -T db psql -U postgres -d postgres -tAc "select 1 from public.schema_migrations where name = '${name}'")"
              if [ "$applied" = "1" ]; then
                echo "Skipping already-applied migration: $name"
                continue
              fi

              # If the droplet was provisioned manually already, the initial schema migration will fail noisily.
              # Detect an existing baseline schema and record the migration without reapplying it.
              if [ "$name" = "20260215000000_initial_schema.sql" ]; then
                has_profiles="$(docker compose exec -T db psql -U postgres -d postgres -tAc "select to_regclass('public.profiles') is not null")"
                if [ "$has_profiles" = "t" ]; then
                  echo "Baseline schema present; recording $name without applying"
                  docker compose exec -T db psql -U postgres -d postgres -v ON_ERROR_STOP=1 \
                    -c "insert into public.schema_migrations(name) values ('${name}') on conflict (name) do nothing;"
                  continue
                fi
              fi

              echo "Applying migration: $name"
              tmp="$(mktemp)"
              # Run with ON_ERROR_STOP=0 to keep a zero exit status (ssh-action stops on non-zero).
              docker compose exec -T db psql -U postgres -d postgres -v ON_ERROR_STOP=0 < "$f" >"$tmp" 2>&1

              if grep -q "ERROR:" "$tmp"; then
                bad="$(grep "ERROR:" "$tmp" | grep -Evi "already exists|duplicate key|already defined|already present|policy .* already exists" || true)"
                if [ -n "$bad" ]; then
                  echo "$bad" >&2
                  rm -f "$tmp"
                  exit 1
                fi
                echo "Migration $name produced only existing-object errors; continuing."
              fi
              rm -f "$tmp"

              docker compose exec -T db psql -U postgres -d postgres -v ON_ERROR_STOP=1 \
                -c "insert into public.schema_migrations(name) values ('${name}') on conflict (name) do nothing;"
            done

            # Sync edge functions into the self-hosted volume.
            echo "Syncing edge functions..."
            mkdir -p "$FUNCTIONS_DST"
            rm -rf "$FUNCTIONS_DST"/*
            cp -R "$DEPLOY_DIR"/supabase/functions/* "$FUNCTIONS_DST"/

            # Restart edge runtime so it picks up updated functions.
            echo "Restarting edge functions runtime..."
            if docker compose ps --services | grep -qx functions; then
              docker compose restart functions
            elif docker compose ps --services | grep -qx edge-runtime; then
              docker compose restart edge-runtime
            else
              echo "edge-runtime service not found; restarting all services" >&2
              docker compose restart
            fi

            echo "Supabase droplet deploy complete."
